<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced WebXR Outdoor Navigation</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #enter-ar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      padding: 12px 24px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    #enter-ar:hover {
      background: #0056b3;
    }
    #debug {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
      max-width: 80%;
      z-index: 1000;
      display: none;
    }
    #status {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 1000;
      display: none;
    }
  </style>
</head>
<body>
  <button id="enter-ar">Start AR Navigation</button>
  <div id="debug"></div>
  <div id="status">Initializing...</div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    class ARNavigator {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          logarithmicDepthBuffer: true
        });

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.xr.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        this.setupLighting();
        this.setupEventListeners();
        
        this.currentPosition = null;
        this.currentOrientation = null;
        this.waypoints = [];
        this.navigationElements = new THREE.Group();
        this.scene.add(this.navigationElements);

        this.debug = document.getElementById('debug');
        this.status = document.getElementById('status');
      }

      setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        this.scene.add(ambientLight);
        this.scene.add(directionalLight);
      }

      setupEventListeners() {
        window.addEventListener('resize', () => {
          if (!this.renderer.xr.isPresenting) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          }
        });
      }

      async initialize() {
        try {
          await this.requestPermissions();
          await this.setupGeolocation();
          await this.setupOrientation();
          await this.loadWaypoints();
          this.startARSession();
        } catch (error) {
          this.showError(`Initialization failed: ${error.message}`);
        }
      }

      async requestPermissions() {
        this.updateStatus('Requesting permissions...');
        
        // Request location permission
        const hasGeolocation = 'geolocation' in navigator;
        if (!hasGeolocation) {
          throw new Error('Geolocation not supported');
        }

        // Request device orientation permission on iOS
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') {
            throw new Error('Orientation permission denied');
          }
        }
      }

      async setupGeolocation() {
        this.updateStatus('Setting up location tracking...');
        
        return new Promise((resolve, reject) => {
          this.watchId = navigator.geolocation.watchPosition(
            (position) => {
              this.currentPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
              };
              this.updateNavigation();
              resolve();
            },
            (error) => reject(`Geolocation error: ${error.message}`),
            {
              enableHighAccuracy: true,
              maximumAge: 0,
              timeout: 5000
            }
          );
        });
      }

      setupOrientation() {
        this.updateStatus('Setting up orientation tracking...');
        
        window.addEventListener('deviceorientationabsolute', (event) => {
          this.currentOrientation = {
            alpha: event.alpha, // compass direction
            beta: event.beta,   // front/back tilt
            gamma: event.gamma  // left/right tilt
          };
          this.updateNavigation();
        });
      }

      async loadWaypoints() {
        this.updateStatus('Loading route...');
        
        const routeId = new URLSearchParams(window.location.search).get('routeId');
        if (!routeId) {
          throw new Error('No route ID provided');
        }

        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        const data = await response.json();
        this.waypoints = data.waypoints || [];
        
        if (this.waypoints.length === 0) {
          throw new Error('No waypoints found');
        }

        this.log(`Loaded ${this.waypoints.length} waypoints`);
      }

      createArrow(isFloating = false) {
        const color = isFloating ? 0x2196F3 : 0xFFEB3B;
        const arrowShape = new THREE.Shape();
        
        // Create arrow shape
        arrowShape.moveTo(0, 0);
        arrowShape.lineTo(0.15, -0.4);
        arrowShape.lineTo(0.05, -0.4);
        arrowShape.lineTo(0.05, -0.6);
        arrowShape.lineTo(-0.05, -0.6);
        arrowShape.lineTo(-0.05, -0.4);
        arrowShape.lineTo(-0.15, -0.4);
        arrowShape.lineTo(0, 0);

        const extrudeSettings = {
          depth: 0.02,
          bevelEnabled: false
        };

        const geometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.3,
          roughness: 0.4,
          transparent: true,
          opacity: 0.9
        });

        const arrow = new THREE.Mesh(geometry, material);

        if (!isFloating) {
          arrow.rotation.x = -Math.PI / 2; // Lay flat for ground arrows
        }

        return arrow;
      }

      createDistanceLabel(distance) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 128;

        context.fillStyle = 'white';
        context.font = 'bold 48px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(`${distance}m`, 128, 64);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.5, 0.25, 1);

        return sprite;
      }

      updateNavigation() {
        if (!this.currentPosition || !this.currentOrientation) return;

        // Clear existing elements
        while (this.navigationElements.children.length > 0) {
          this.navigationElements.remove(this.navigationElements.children[0]);
        }

        // Find closest waypoint
        const closestWaypoint = this.findClosestWaypoint();
        if (!closestWaypoint) return;

        // Create new navigation elements
        const arrow = this.createArrow(true);
        const bearing = this.calculateBearing(
          this.currentPosition.lat,
          this.currentPosition.lng,
          closestWaypoint.lat,
          closestWaypoint.lng
        );

        // Position arrow based on device orientation
        const compassHeading = 360 - this.currentOrientation.alpha;
        const rotation = (bearing - compassHeading) * Math.PI / 180;
        arrow.rotation.y = rotation;

        // Add distance indicator
        const distance = this.calculateDistance(closestWaypoint);
        const distanceLabel = this.createDistanceLabel(Math.round(distance));
        distanceLabel.position.y = 0.5;

        const container = new THREE.Group();
        container.add(arrow);
        container.add(distanceLabel);

        // Position in front of user
        container.position.z = -2;
        container.position.y = 1.6; // Approximate eye level

        this.navigationElements.add(container);
        
        // Update status
        this.updateStatus(`${Math.round(distance)}m to next turn`);
      }

      calculateDistance(waypoint) {
        const R = 6371000; // Earth's radius in meters
        const φ1 = this.currentPosition.lat * Math.PI / 180;
        const φ2 = waypoint.lat * Math.PI / 180;
        const Δφ = (waypoint.lat - this.currentPosition.lat) * Math.PI / 180;
        const Δλ = (waypoint.lng - this.currentPosition.lng) * Math.PI / 180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                 Math.cos(φ1) * Math.cos(φ2) *
                 Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
      }

      calculateBearing(lat1, lon1, lat2, lon2) {
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const λ1 = lon1 * Math.PI / 180;
        const λ2 = lon2 * Math.PI / 180;

        const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) -
                 Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);

        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
      }

      findClosestWaypoint() {
        let closest = null;
        let minDistance = Infinity;

        for (const waypoint of this.waypoints) {
          const distance = this.calculateDistance(waypoint);
          if (distance < minDistance) {
            minDistance = distance;
            closest = waypoint;
          }
        }

        return closest;
      }

      async startARSession() {
        this.updateStatus('Starting AR...');
        
        try {
          const arButton = ARButton.createButton(this.renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          });
          document.body.appendChild(arButton);

          this.renderer.setAnimationLoop(() => {
            this.renderer.render(this.scene, this.camera);
          });
        } catch (error) {
          this.showError(`AR session failed: ${error.message}`);
        }
      }

      updateStatus(message) {
        this.status.textContent = message;
        this.status.style.display = 'block';
      }

      showError(message) {
        this.updateStatus(`Error: ${message}`);
        console.error(message);
      }

      log(message) {
        console.log(message);
        this.debug.textContent += message + '\n';
        this.debug.style.display = 'block';
      }

      dispose() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
        }
        this.renderer.dispose();
      }
    }

    // Initialize the application
    const arNavigator = new ARNavigator();
    
    document.getElementById('enter-ar').addEventListener('click', async () => {
      try {
        document.getElementById('enter-ar').style.display = 'none';
        await arNavigator.initialize();
      } catch (error) {
        console.error('Failed to initialize AR:', error);
        alert(`Failed to start AR: ${error.message}`);
      }
    });
  </script>
</body>
</html>
