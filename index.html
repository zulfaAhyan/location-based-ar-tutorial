<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Navigation</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000;
    }
    #enter-ar {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999;
      padding: 16px 32px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(0,123,255,0.3);
      transition: all 0.3s ease;
    }
    #enter-ar:hover {
      background: #0056b3;
      transform: translate(-50%, -50%) scale(1.05);
    }
    #status {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
    }
    #compass {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      background: rgba(0,0,0,0.8);
      border: 2px solid #007bff;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      backdrop-filter: blur(10px);
    }
    .compass-needle {
      position: absolute;
      width: 2px;
      height: 30px;
      background: #ff4444;
      transform-origin: bottom center;
    }
    #distance-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
    }
    .loading-spinner {
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 3px solid #007bff;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <button id="enter-ar">Start AR Navigation</button>
  <div id="status">
    <div class="loading-spinner"></div>
    Initializing GPS...
  </div>
  <div id="compass">
    <div class="compass-needle"></div>
    <div>N</div>
  </div>
  <div id="distance-info">
    <div id="next-waypoint">Calculating route...</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // UI elements
    const statusDiv = document.getElementById('status');
    const compassDiv = document.getElementById('compass');
    const distanceDiv = document.getElementById('distance-info');
    const nextWaypointDiv = document.getElementById('next-waypoint');
    const compassNeedle = document.querySelector('.compass-needle');

    function updateStatus(message, isError = false) {
      statusDiv.innerHTML = isError ? 
        `<div style="color: #ff4444;">${message}</div>` : 
        `<div class="loading-spinner"></div>${message}`;
      statusDiv.style.display = 'block';
      console.log(message);
    }

    function hideStatus() {
      statusDiv.style.display = 'none';
    }

    // Lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 10, 0);
    scene.add(directionalLight);

    // Navigation state
    let userPosition = null;
    let userHeading = null;
    let waypoints = [];
    let navigationObjects = [];
    let isARActive = false;

    // Create yellow chevron arrow (original design)
    function createNavArrow() {
      const shape = new THREE.Shape();
      shape.moveTo(-0.5, -0.5);
      shape.lineTo(0, 0.5);
      shape.lineTo(0.5, -0.5);
      shape.lineTo(-0.5, -0.5);
      
      const geometry = new THREE.ShapeGeometry(shape);
      const material = new THREE.MeshStandardMaterial({ 
        color: 0xffff00,
        transparent: true,
        opacity: 0.9,
        emissive: 0xffff00,
        emissiveIntensity: 0.5,
        side: THREE.DoubleSide
      });
      
      const arrow = new THREE.Mesh(geometry, material);
      arrow.rotation.x = -Math.PI / 2;
      arrow.scale.set(0.3, 0.3, 0.3);
      
      return arrow;
    }

    // Create destination marker
    function createDestination() {
      const group = new THREE.Group();
      
      // Pin body
      const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0x440000,
        emissiveIntensity: 0.3
      });
      
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      
      // Pin top
      const topGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const top = new THREE.Mesh(topGeometry, bodyMaterial);
      top.position.y = 0.8;
      
      // Flag
      const flagGeometry = new THREE.PlaneGeometry(0.8, 0.5);
      const flagMaterial = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      
      const flag = new THREE.Mesh(flagGeometry, flagMaterial);
      flag.position.set(0.6, 1.2, 0);
      
      group.add(body);
      group.add(top);
      group.add(flag);
      
      return group;
    }

    // GPS and compass functions
    function initializeGPS() {
      if (!navigator.geolocation) {
        updateStatus("GPS not available on this device", true);
        return;
      }

      const options = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 2000
      };

      navigator.geolocation.watchPosition(
        (position) => {
          userPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy
          };
          
          updateStatus(`GPS accuracy: ${Math.round(position.coords.accuracy)}m`);
          
          if (position.coords.accuracy < 50) {
            setTimeout(hideStatus, 2000);
            updateNavigation();
          }
        },
        (error) => {
          updateStatus(`GPS Error: ${error.message}`, true);
        },
        options
      );
    }

    function initializeCompass() {
      if (!window.DeviceOrientationEvent) {
        return;
      }

      // Request permission on iOS 13+
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response == 'granted') {
              startCompass();
            }
          })
          .catch(console.error);
      } else {
        startCompass();
      }

      function startCompass() {
        window.addEventListener('deviceorientationabsolute', handleOrientation, true);
        window.addEventListener('deviceorientation', handleOrientation, true);
      }

      function handleOrientation(event) {
        if (event.alpha !== null) {
          userHeading = event.webkitCompassHeading || (360 - event.alpha);
          
          compassNeedle.style.transform = `rotate(${-userHeading}deg)`;
          compassDiv.style.display = 'flex';
          
          updateNavigation();
        }
      }
    }

    // Navigation calculations
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
               Math.cos(φ1) * Math.cos(φ2) *
               Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      
      return R * c;
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      
      let bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    function updateNavigation() {
      if (!userPosition || !waypoints.length || !isARActive) return;

      // Clear existing navigation objects
      navigationObjects.forEach(obj => scene.remove(obj));
      navigationObjects = [];

      // Find closest waypoint
      let nextWaypoint = null;
      let minDistance = Infinity;

      waypoints.forEach((wp, index) => {
        if (!wp.lat || !wp.lng) return;
        
        const distance = calculateDistance(userPosition.lat, userPosition.lng, wp.lat, wp.lng);
        if (distance < minDistance && distance > 5) { // Skip if too close (already passed)
          minDistance = distance;
          nextWaypoint = { ...wp, index, distance };
        }
      });

      if (!nextWaypoint) {
        nextWaypointDiv.textContent = "Destination reached!";
        distanceDiv.style.display = 'block';
        return;
      }

      // Update UI
      nextWaypointDiv.innerHTML = `
        <strong>Next:</strong> ${Math.round(nextWaypoint.distance)}m ahead<br>
        <small>Waypoint ${nextWaypoint.index + 1} of ${waypoints.length}</small>
      `;
      distanceDiv.style.display = 'block';

      // Calculate relative position for AR
      const bearing = calculateBearing(userPosition.lat, userPosition.lng, nextWaypoint.lat, nextWaypoint.lng);
      let relativeBearing = bearing;
      
      if (userHeading !== null) {
        relativeBearing = (bearing - userHeading + 360) % 360;
      }

      const bearingRad = relativeBearing * Math.PI / 180;
      const distance = Math.min(nextWaypoint.distance, 50); // Cap AR distance
      const scale = distance / 10; // Scale for AR view

      // Place navigation arrow
      const arrow = createNavArrow();
      arrow.position.x = Math.sin(bearingRad) * scale;
      arrow.position.z = -Math.cos(bearingRad) * scale;
      arrow.position.y = 0.01;
      
      // Rotate arrow to point toward destination
      arrow.rotation.y = -bearingRad;

      scene.add(arrow);
      navigationObjects.push(arrow);

      // Add destination marker for final waypoint
      const finalWaypoint = waypoints[waypoints.length - 1];
      if (finalWaypoint && finalWaypoint !== nextWaypoint) {
        const finalDistance = calculateDistance(userPosition.lat, userPosition.lng, finalWaypoint.lat, finalWaypoint.lng);
        if (finalDistance < 100) {
          const finalBearing = calculateBearing(userPosition.lat, userPosition.lng, finalWaypoint.lat, finalWaypoint.lng);
          let finalRelativeBearing = finalBearing;
          
          if (userHeading !== null) {
            finalRelativeBearing = (finalBearing - userHeading + 360) % 360;
          }

          const finalBearingRad = finalRelativeBearing * Math.PI / 180;
          const finalScale = finalDistance / 10;

          const destination = createDestination();
          destination.position.x = Math.sin(finalBearingRad) * finalScale;
          destination.position.z = -Math.cos(finalBearingRad) * finalScale;
          destination.position.y = 0;

          scene.add(destination);
          navigationObjects.push(destination);
        }
      }
    }

    // Load waypoints from server
    async function loadWaypoints() {
      const routeId = new URLSearchParams(window.location.search).get('routeId');
      if (!routeId) {
        throw new Error("No route ID provided in URL");
      }

      updateStatus("Loading route data...");
      
      try {
        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        if (!response.ok) {
          throw new Error(`Server error: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.waypoints || data.waypoints.length === 0) {
          throw new Error("No waypoints found for this route");
        }
        
        waypoints = data.waypoints;
        updateStatus(`Route loaded: ${waypoints.length} waypoints`);
        
      } catch (error) {
        throw new Error(`Failed to load route: ${error.message}`);
      }
    }

    // AR setup
    async function startAR() {
      try {
        updateStatus("Checking AR support...");
        
        if (!('xr' in navigator)) {
          throw new Error("WebXR not supported on this device");
        }

        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          throw new Error("AR not supported on this browser");
        }

        updateStatus("Starting AR session...");

        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });

        renderer.xr.setSession(session);
        isARActive = true;
        
        hideStatus();

        // Initialize GPS and compass after AR starts
        initializeGPS();
        initializeCompass();

        // Update navigation every 3 seconds
        setInterval(updateNavigation, 3000);

        session.addEventListener('end', () => {
          isARActive = false;
          distanceDiv.style.display = 'none';
          compassDiv.style.display = 'none';
        });

      } catch (error) {
        updateStatus(`AR Error: ${error.message}`, true);
        console.error('AR Error:', error);
      }
    }

    // Main initialization
    document.getElementById("enter-ar").addEventListener("click", async () => {
      try {
        await loadWaypoints();
        await startAR();
        document.getElementById("enter-ar").style.display = "none";
      } catch (error) {
        updateStatus(error.message, true);
      }
    });

    // Render loop
    renderer.setAnimationLoop(() => {
      renderer.render(scene, camera);
    });

    // Handle window resize
    window.addEventListener("resize", () => {
      if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>
