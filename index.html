<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Enhanced GeoAR.js Navigation demo</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <script>
      const smoothedPosition = { lat: 0, lng: 0 };
      const positionHistory = [];
      const historyLength = 5;
      let currentWaypointIndex = 0;
      let waypoints = [];

      function updatePosition(newLat, newLng) {
        positionHistory.push({ lat: newLat, lng: newLng });
        if (positionHistory.length > historyLength) {
          positionHistory.shift();
        }
      
        const sum = positionHistory.reduce((acc, pos) => ({
          lat: acc.lat + pos.lat,
          lng: acc.lng + pos.lng
        }), { lat: 0, lng: 0 });
      
        smoothedPosition.lat = sum.lat / positionHistory.length;
        smoothedPosition.lng = sum.lng / positionHistory.length;
      
        updateNavigationArrow();
        checkWaypointProximity();
      }

      function getRouteIdFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('routeId');
      }

      async function fetchWaypoints(routeId) {
        try {
          const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return await response.json();
        } catch (error) {
          console.error('Error fetching waypoints:', error);
          return [];
        }
      }

      function createWaypointEntities(waypoints) {
        const scene = document.querySelector('a-scene');
        waypoints.forEach((waypoint, index) => {
          // Create waypoint marker
          const entity = document.createElement('a-sphere');
          entity.setAttribute('radius', '0.5');
          entity.setAttribute('color', index === 0 ? 'green' : (index === waypoints.length - 1 ? 'red' : 'blue'));
          entity.setAttribute('gps-entity-place', `latitude: ${waypoint.lat}; longitude: ${waypoint.lng};`);
          scene.appendChild(entity);

          // Create text label
          const label = document.createElement('a-text');
          label.setAttribute('value', `${index + 1}`);
          label.setAttribute('look-at', '[gps-camera]');
          label.setAttribute('scale', '5 5 5');
          label.setAttribute('align', 'center');
          label.setAttribute('color', 'white');
          label.setAttribute('gps-entity-place', `latitude: ${waypoint.lat}; longitude: ${waypoint.lng};`);
          scene.appendChild(label);

          // Create line to next waypoint
          if (index < waypoints.length - 1) {
            const nextWaypoint = waypoints[index + 1];
            const line = document.createElement('a-entity');
            line.setAttribute('line', `start: ${waypoint.lng} 1.6 ${-waypoint.lat}; end: ${nextWaypoint.lng} 1.6 ${-nextWaypoint.lat}; color: yellow`);
            scene.appendChild(line);
          }
        });

        // Create navigation arrow
        const arrow = document.createElement('a-entity');
        arrow.setAttribute('geometry', 'primitive: cone; radiusBottom: 0.5; radiusTop: 0');
        arrow.setAttribute('material', 'color: red');
        arrow.setAttribute('rotation', '90 0 0');
        arrow.setAttribute('scale', '1 2 1');
        arrow.setAttribute('id', 'navigation-arrow');
        arrow.setAttribute('gps-entity-place', `latitude: ${smoothedPosition.lat}; longitude: ${smoothedPosition.lng};`);
        scene.appendChild(arrow);
      }

      function updateNavigationArrow() {
        const arrow = document.getElementById('navigation-arrow');
        if (arrow && currentWaypointIndex < waypoints.length) {
          const targetWaypoint = waypoints[currentWaypointIndex];
          const dx = targetWaypoint.lng - smoothedPosition.lng;
          const dy = targetWaypoint.lat - smoothedPosition.lat;
          const angle = Math.atan2(dy, dx) * (180 / Math.PI);
          arrow.setAttribute('rotation', `90 0 ${angle}`);
          arrow.setAttribute('gps-entity-place', `latitude: ${smoothedPosition.lat}; longitude: ${smoothedPosition.lng};`);
        }
      }

      function checkWaypointProximity() {
        if (currentWaypointIndex < waypoints.length) {
          const targetWaypoint = waypoints[currentWaypointIndex];
          const distance = calculateDistance(smoothedPosition, targetWaypoint);
          if (distance < 10) { // 10 meters proximity
            currentWaypointIndex++;
            updateNavigationArrow();
            if (currentWaypointIndex < waypoints.length) {
              showDirectionMessage(`Proceed to waypoint ${currentWaypointIndex + 1}`);
            } else {
              showDirectionMessage("You have reached your destination!");
            }
          }
        }
      }

      function calculateDistance(pos1, pos2) {
        const R = 6371e3; // Earth's radius in meters
        const φ1 = pos1.lat * Math.PI / 180;
        const φ2 = pos2.lat * Math.PI / 180;
        const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180;
        const Δλ = (pos2.lng - pos1.lng) * Math.PI / 180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
      }

      function showDirectionMessage(message) {
        const directionDisplay = document.getElementById('direction-display');
        directionDisplay.textContent = message;
      }

      async function init() {
        const routeId = getRouteIdFromUrl();
        if (routeId) {
          waypoints = await fetchWaypoints(routeId);
          createWaypointEntities(waypoints);
        }

        // Simulate GPS updates (replace with real GPS data in production)
        setInterval(() => {
          const newLat = smoothedPosition.lat + (Math.random() - 0.5) * 0.0001;
          const newLng = smoothedPosition.lng + (Math.random() - 0.5) * 0.0001;
          updatePosition(newLat, newLng);
        }, 1000);
      }

      window.onload = init;
    </script>
    <style>
      #direction-display {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 18px;
        z-index: 1000;
      }
    </style>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <div id="direction-display"></div>
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
    >
      <a-camera gps-camera rotation-reader></a-camera>
    </a-scene>
  </body>
</html>
