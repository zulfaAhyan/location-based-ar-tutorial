<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emergency Response AR Navigation</title>
  <!-- Add Google Maps API -->
  <script async src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    #info {
      position: fixed;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      z-index: 100;
    }
    #compass {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(0,0,0,0.7);
      z-index: 100;
    }
    #distance {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
  </style>
  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    let scene, camera, renderer, session;
    let currentLocation = null;
    let waypoints = [];
    let markers = [];
    
    // Initialize Scene
    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true,
        logarithmicDepthBuffer: true
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      
      document.body.appendChild(renderer.domElement);
      
      // Add lighting
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);
      
      // Add directional light for better visibility
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(1, 1, 1);
      scene.add(dirLight);
    }

    // Load waypoints from server and convert to Earth coordinates
    async function loadWaypoints() {
      const routeId = new URLSearchParams(window.location.search).get('routeId');
      if (!routeId) return [];
      
      try {
        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        const data = await response.json();
        return data.map(wp => ({
          latitude: wp.lat,
          longitude: wp.lng,
          altitude: 0
        }));
      } catch (error) {
        console.error("Error loading waypoints:", error);
        return [];
      }
    }

    // Create visual elements for waypoints
    function createWaypointVisuals(earthPosition, index) {
      const group = new THREE.Group();
      
      // Main marker pillar
      const pillar = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 5, 32),
        new THREE.MeshStandardMaterial({ 
          color: new THREE.Color(0.0, 0.5, 1.0),
          transparent: true,
          opacity: 0.8
        })
      );
      pillar.position.y = 2.5;
      group.add(pillar);
      
      // Animated beacon
      const beacon = new THREE.Mesh(
        new THREE.SphereGeometry(0.7, 32, 32),
        new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0x0066ff,
          emissiveIntensity: 1
        })
      );
      beacon.position.y = 5.5;
      group.add(beacon);
      
      // Distance text
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 256;
      
      const texture = new THREE.CanvasTexture(canvas);
      const textMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide
        })
      );
      textMesh.position.y = 6.5;
      group.add(textMesh);
      
      return {
        group,
        beacon,
        textMesh,
        updateDistance: (distance) => {
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.fillStyle = 'white';
          context.font = '48px Arial';
          context.textAlign = 'center';
          context.fillText(`${Math.round(distance)}m`, canvas.width/2, canvas.height/2);
          texture.needsUpdate = true;
        }
      };
    }

    // Initialize AR session with Geospatial API
    async function initAR() {
      // Check for Geospatial API support
      if (!navigator.xr || !('geospatial' in navigator.xr)) {
        throw new Error('Geospatial API not supported');
      }
      
      session = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['geospatial'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });

      // Set up session
      session.updateRenderState({
        baseLayer: new XRWebGLLayer(session, renderer)
      });

      // Initialize Earth coordinates
      const geoOrigin = await session.requestReferenceSpace('geospatial');
      
      // Load and place waypoints
      waypoints = await loadWaypoints();
      
      // Create visual markers for each waypoint
      waypoints.forEach((waypoint, index) => {
        const visual = createWaypointVisuals(waypoint, index);
        markers.push(visual);
        scene.add(visual.group);
      });
      
      // Start render loop
      session.requestAnimationFrame(render);
    }

    // Main render loop
    function render(time, frame) {
      if (!session || !frame) return;
      
      // Get current location
      const geoSpace = frame.getCoordinateSystem('geographic');
      if (geoSpace) {
        const pose = frame.getViewerPose(geoSpace);
        if (pose) {
          currentLocation = {
            latitude: pose.transform.position.x,
            longitude: pose.transform.position.z,
            altitude: pose.transform.position.y
          };
          
          // Update marker positions and info
          updateMarkers();
        }
      }
      
      renderer.render(scene, camera);
      session.requestAnimationFrame(render);
    }

    // Update marker positions and information
    function updateMarkers() {
      markers.forEach((marker, index) => {
        const waypoint = waypoints[index];
        
        // Calculate distance and bearing to waypoint
        const distance = calculateDistance(
          currentLocation.latitude,
          currentLocation.longitude,
          waypoint.latitude,
          waypoint.longitude
        );
        
        const bearing = calculateBearing(
          currentLocation.latitude,
          currentLocation.longitude,
          waypoint.latitude,
          waypoint.longitude
        );
        
        // Update marker position
        const position = geoToScene(waypoint.latitude, waypoint.longitude);
        marker.group.position.set(position.x, 0, position.z);
        
        // Update distance display
        marker.updateDistance(distance);
        
        // Animate beacon
        marker.beacon.position.y = 5.5 + Math.sin(Date.now() * 0.003) * 0.2;
        
        // Update visibility based on distance
        const opacity = Math.min(1, Math.max(0.2, 100 / distance));
        marker.group.children.forEach(child => {
          if (child.material) {
            child.material.opacity = opacity;
          }
        });
      });
    }

    // Utility functions
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const φ1 = lat1 * Math.PI/180;
      const φ2 = lat2 * Math.PI/180;
      const Δφ = (lat2-lat1) * Math.PI/180;
      const Δλ = (lon2-lon1) * Math.PI/180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      return R * c;
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI/180;
      const φ2 = lat2 * Math.PI/180;
      const λ1 = lon1 * Math.PI/180;
      const λ2 = lon2 * Math.PI/180;

      const y = Math.sin(λ2-λ1) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) -
                Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
      return Math.atan2(y, x);
    }

    function geoToScene(lat, lon) {
      // Convert geo coordinates to scene coordinates
      // This will need to be adjusted based on your coordinate system
      const scale = 1; // Meters to scene units
      return {
        x: (lon - currentLocation.longitude) * 111319.9 * scale,
        z: (lat - currentLocation.latitude) * 111319.9 * scale
      };
    }

    // Initialize everything
    async function initAR() {
      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        console.log('AR supported:', supported);
        
        if (!supported) {
          throw new Error('AR not supported on this device/browser');
        }
    
        session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],  // Start with basic AR
          optionalFeatures: ['dom-overlay', 'geospatial'],
          domOverlay: { root: document.body }
        });
        console.log('Session created:', session);
    
        // Set up session
        session.updateRenderState({
          baseLayer: new XRWebGLLayer(session, renderer)
        });
    
        try {
          // Try geospatial features if available
          const geoOrigin = await session.requestReferenceSpace('geospatial');
          console.log('Geospatial support enabled');
        } catch (geoError) {
          console.log('Geospatial not available, falling back to device tracking');
          // Fall back to basic AR tracking
          const localSpace = await session.requestReferenceSpace('local');
          useGeolocationFallback();
        }
    
        // Load and place waypoints
        waypoints = await loadWaypoints();
        waypoints.forEach((waypoint, index) => {
          const visual = createWaypointVisuals(waypoint, index);
          markers.push(visual);
          scene.add(visual.group);
        });
    
        session.requestAnimationFrame(render);
      } catch (error) {
        console.error('Detailed AR init error:', error);
        useGeolocationFallback();
        throw error;
      }
    }
    
    function useGeolocationFallback() {
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          position => {
            currentLocation = {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              altitude: position.coords.altitude || 0
            };
            updateMarkers();
          },
          error => console.error('Geolocation error:', error),
          {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 20000
          }
        );
      }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start everything when page loads
    window.addEventListener('load', init);
  </script>
</head>
<body style="margin: 0; overflow: hidden;">
</body>
</html>
