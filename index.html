<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Navigation - Improved</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000;
    }
    #enter-ar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      padding: 12px 24px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    #enter-ar:hover {
      background: #0056b3;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 20px;
      border-radius: 8px;
      display: none;
      text-align: center;
    }
    #debug {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-size: 12px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      display: none;
      max-height: 200px;
      overflow-y: auto;
    }
    #gps-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-size: 12px;
      border-radius: 4px;
    }
    #calibration {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(255,165,0,0.9);
      color: black;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 4px;
      display: none;
    }
  </style>
</head>
<body>
  <button id="enter-ar">Enter AR Navigation</button>
  <div id="loading">Loading navigation...</div>
  <div id="debug"></div>
  <div id="gps-info">GPS: Waiting...</div>
  <div id="calibration">Move device in figure-8 to calibrate compass</div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Enhanced scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      alpha: true,
      powerPreference: "high-performance"
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.xr.enabled = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Enhanced debug and GPS tracking
    const debug = document.getElementById('debug');
    const gpsInfo = document.getElementById('gps-info');
    const calibrationDiv = document.getElementById('calibration');
    
    let currentPosition = null;
    let currentHeading = null;
    let isCalibrated = false;
    let headingHistory = [];
    let positionHistory = [];
    
    function log(message) {
      console.log(message);
      const timestamp = new Date().toLocaleTimeString();
      debug.innerHTML = `[${timestamp}] ${message}<br>` + debug.innerHTML;
      debug.style.display = 'block';
      // Keep only last 10 messages
      const lines = debug.innerHTML.split('<br>');
      if (lines.length > 10) {
        debug.innerHTML = lines.slice(0, 10).join('<br>');
      }
    }

    // Enhanced lighting for better visibility
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Enhanced GPS position tracking with filtering
    function startGPSTracking() {
      if (!navigator.geolocation) {
        log("GPS not supported");
        return;
      }

      const options = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 1000
      };

      navigator.geolocation.watchPosition(
        (position) => {
          const newPos = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy,
            heading: position.coords.heading,
            timestamp: Date.now()
          };

          // Filter out inaccurate readings
          if (newPos.accuracy > 50) {
            log(`GPS accuracy too low: ${newPos.accuracy}m`);
            return;
          }

          // Smooth position using moving average
          positionHistory.push(newPos);
          if (positionHistory.length > 5) {
            positionHistory.shift();
          }

          // Calculate smoothed position
          const avgLat = positionHistory.reduce((sum, p) => sum + p.lat, 0) / positionHistory.length;
          const avgLng = positionHistory.reduce((sum, p) => sum + p.lng, 0) / positionHistory.length;
          
          currentPosition = {
            lat: avgLat,
            lng: avgLng,
            accuracy: newPos.accuracy
          };

          gpsInfo.textContent = `GPS: ${newPos.accuracy.toFixed(1)}m | Pos: ${positionHistory.length}`;
          
          if (newPos.accuracy < 10) {
            gpsInfo.style.background = 'rgba(0,128,0,0.7)';
          } else if (newPos.accuracy < 20) {
            gpsInfo.style.background = 'rgba(255,165,0,0.7)';
          } else {
            gpsInfo.style.background = 'rgba(255,0,0,0.7)';
          }

          log(`GPS updated: ${newPos.accuracy.toFixed(1)}m accuracy`);
          updateNavigation();
        },
        (error) => {
          log(`GPS Error: ${error.message}`);
          gpsInfo.textContent = `GPS Error: ${error.message}`;
          gpsInfo.style.background = 'rgba(255,0,0,0.7)';
        },
        options
      );
    }

    // Enhanced compass with calibration
    function startCompassTracking() {
      if (!window.DeviceOrientationEvent) {
        log("Device orientation not supported");
        return;
      }

      // Show calibration prompt
      calibrationDiv.style.display = 'block';
      setTimeout(() => {
        calibrationDiv.style.display = 'none';
      }, 10000);

      window.addEventListener('deviceorientationabsolute', handleOrientation);
      window.addEventListener('deviceorientation', handleOrientation);

      function handleOrientation(event) {
        let heading = event.alpha;
        if (heading === null) return;

        // iOS compass correction
        if (event.webkitCompassHeading) {
          heading = event.webkitCompassHeading;
        }

        // Smooth heading using circular average
        headingHistory.push(heading);
        if (headingHistory.length > 10) {
          headingHistory.shift();
        }

        if (headingHistory.length >= 5) {
          currentHeading = calculateCircularAverage(headingHistory);
          isCalibrated = true;
          calibrationDiv.style.display = 'none';
        }

        gpsInfo.textContent += ` | Heading: ${Math.round(currentHeading || heading)}°`;
        updateNavigation();
      }
    }

    function calculateCircularAverage(angles) {
      let x = 0, y = 0;
      for (let angle of angles) {
        const rad = angle * Math.PI / 180;
        x += Math.cos(rad);
        y += Math.sin(rad);
      }
      const avgRad = Math.atan2(y, x);
      let avgAngle = avgRad * 180 / Math.PI;
      if (avgAngle < 0) avgAngle += 360;
      return avgAngle;
    }

    // Improved distance calculation with higher precision
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6378137; // Earth's radius in meters (WGS84)
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const A = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
               Math.cos(φ1) * Math.cos(φ2) *
               Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
      
      return R * C;
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      
      let bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    // Enhanced arrow creation with better visibility
    function createNavigationArrow() {
      const group = new THREE.Group();
      
      // Main arrow body
      const arrowGeometry = new THREE.ConeGeometry(0.15, 0.6, 8);
      const arrowMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x004400,
        emissiveIntensity: 0.3,
      });
      
      const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
      arrow.rotation.x = Math.PI / 2;
      arrow.castShadow = true;
      
      // Glow effect
      const glowGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.3
      });
      
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.rotation.x = Math.PI / 2;
      
      group.add(arrow);
      group.add(glow);
      
      return group;
    }

    // Enhanced destination marker
    function createDestinationMarker() {
      const group = new THREE.Group();
      
      // Pin base
      const pinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16);
      const pinMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0x440000,
        emissiveIntensity: 0.2
      });
      
      const pin = new THREE.Mesh(pinGeometry, pinMaterial);
      pin.castShadow = true;
      
      // Pin top
      const topGeometry = new THREE.SphereGeometry(0.25, 16, 8);
      const topMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x222222,
        emissiveIntensity: 0.1
      });
      
      const top = new THREE.Mesh(topGeometry, topMaterial);
      top.position.y = 0.6;
      top.castShadow = true;
      
      group.add(pin);
      group.add(top);
      
      return group;
    }

    // Navigation state
    let waypoints = [];
    let navigationArrows = [];
    let destinationMarker = null;
    let currentWaypointIndex = 0;

    async function loadWaypoints() {
      const routeId = new URLSearchParams(window.location.search).get('routeId');
      if (!routeId) {
        log("No route ID provided");
        return [];
      }
      
      try {
        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        const data = await response.json();
        log(`Loaded ${data.waypoints?.length || 0} waypoints from server`);
        return data.waypoints || [];
      } catch (error) {
        log(`Error fetching waypoints: ${error.message}`);
        return [];
      }
    }

    function updateNavigation() {
      if (!currentPosition || !isCalibrated || !waypoints.length) return;

      // Find next waypoint
      let nextWaypoint = null;
      let minDistance = Infinity;
      
      for (let i = currentWaypointIndex; i < waypoints.length; i++) {
        const distance = calculateDistance(
          currentPosition.lat, currentPosition.lng,
          waypoints[i].lat, waypoints[i].lng
        );
        
        if (distance < minDistance) {
          minDistance = distance;
          nextWaypoint = waypoints[i];
          currentWaypointIndex = i;
        }
        
        // If we're close to current waypoint, move to next
        if (distance < 5 && i < waypoints.length - 1) {
          currentWaypointIndex = i + 1;
        }
      }

      if (!nextWaypoint) return;

      // Calculate direction to next waypoint
      const bearing = calculateBearing(
        currentPosition.lat, currentPosition.lng,
        nextWaypoint.lat, nextWaypoint.lng
      );
      
      const distance = calculateDistance(
        currentPosition.lat, currentPosition.lng,
        nextWaypoint.lat, nextWaypoint.lng
      );

      // Update navigation arrows
      updateNavigationDisplay(bearing, distance);
      
      log(`Next waypoint: ${distance.toFixed(1)}m at ${bearing.toFixed(1)}°`);
    }

    function updateNavigationDisplay(bearing, distance) {
      // Clear existing arrows
      navigationArrows.forEach(arrow => scene.remove(arrow));
      navigationArrows = [];

      // Calculate relative bearing to device heading
      const relativeBearing = (bearing - (currentHeading || 0) + 360) % 360;
      
      // Create navigation arrows in a line ahead
      const arrowCount = Math.min(5, Math.max(2, Math.floor(distance / 10)));
      
      for (let i = 0; i < arrowCount; i++) {
        const arrow = createNavigationArrow();
        
        // Position arrows in direction of target
        const arrowDistance = (i + 1) * 3; // 3 meters apart
        const angleRad = relativeBearing * Math.PI / 180;
        
        arrow.position.x = Math.sin(angleRad) * arrowDistance;
        arrow.position.z = Math.cos(angleRad) * arrowDistance;
        arrow.position.y = 0.3;
        
        // Point arrow in direction of travel
        arrow.rotation.y = -angleRad;
        
        // Scale based on distance
        const scale = Math.max(0.5, 1 - (distance / 100));
        arrow.scale.set(scale, scale, scale);
        
        scene.add(arrow);
        navigationArrows.push(arrow);
      }

      // Update destination marker position
      if (destinationMarker && distance < 50) {
        const finalWaypoint = waypoints[waypoints.length - 1];
        const finalBearing = calculateBearing(
          currentPosition.lat, currentPosition.lng,
          finalWaypoint.lat, finalWaypoint.lng
        );
        const finalRelativeBearing = (finalBearing - (currentHeading || 0) + 360) % 360;
        const finalDistance = calculateDistance(
          currentPosition.lat, currentPosition.lng,
          finalWaypoint.lat, finalWaypoint.lng
        );
        
        const angleRad = finalRelativeBearing * Math.PI / 180;
        destinationMarker.position.x = Math.sin(angleRad) * Math.min(finalDistance, 20);
        destinationMarker.position.z = Math.cos(angleRad) * Math.min(finalDistance, 20);
      }
    }

    async function initNavigation() {
      document.getElementById('loading').style.display = 'block';
      
      try {
        waypoints = await loadWaypoints();
        if (!waypoints.length) throw new Error("No waypoints found");

        log(`Loaded ${waypoints.length} waypoints`);

        // Create destination marker
        destinationMarker = createDestinationMarker();
        destinationMarker.position.set(0, 0, 10); // Initial position
        scene.add(destinationMarker);

        // Start tracking
        startGPSTracking();
        startCompassTracking();

        document.getElementById('loading').style.display = 'none';
        log("Navigation initialized");
        
      } catch (error) {
        log(`Navigation error: ${error.message}`);
        document.getElementById('loading').textContent = `Error: ${error.message}`;
      }
    }

    // AR Session Management
    async function startAR() {
      try {
        if (!('xr' in navigator)) throw new Error("WebXR not supported");
        
        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay', 'local-floor']
        });
        
        renderer.xr.setSession(session);
        log("AR session started");
        
      } catch (error) {
        log(`AR Error: ${error.message}`);
        
        // Fallback: Create AR button
        const arButton = ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        document.body.appendChild(arButton);
      }
    }

    // Main render loop
    renderer.setAnimationLoop((timestamp, frame) => {
      // Update navigation if we have current position
      if (currentPosition && isCalibrated) {
        updateNavigation();
      }
      
      // Animate arrows
      navigationArrows.forEach((arrow, index) => {
        arrow.rotation.y += 0.01;
        arrow.position.y = 0.3 + Math.sin(timestamp * 0.003 + index) * 0.1;
      });
      
      // Animate destination marker
      if (destinationMarker) {
        destinationMarker.rotation.y += 0.02;
        destinationMarker.position.y = Math.sin(timestamp * 0.002) * 0.2 + 1.0;
      }
      
      renderer.render(scene, camera);
    });

    // Event handlers
    document.getElementById("enter-ar").addEventListener("click", async () => {
      await initNavigation();
      await startAR();
      document.getElementById("enter-ar").style.display = "none";
    });

    window.addEventListener("resize", () => {
      if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // Debug toggle
    document.addEventListener('keydown', (e) => {
      if (e.key === 'd' || e.key === 'D') {
        debug.style.display = debug.style.display === 'none' ? 'block' : 'none';
      }
    });
  </script>
</body>
</html>
