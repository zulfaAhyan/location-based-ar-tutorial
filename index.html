<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #ar-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
        #start-button {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
        }
        #error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            display: none;
            text-align: center;
        }
        #fallback-mode {
            display: none;
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: #FFA500;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="ar-canvas"></canvas>
    <div id="info" class="ui-overlay">
        Loading...
    </div>
    <button id="start-button">Start AR Navigation</button>
    <button id="fallback-mode">Use Non-AR Mode</button>
    <div id="error-message"></div>

    <script async src="https://unpkg.com/es-module-shims@1.7.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.151.3/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.151.3/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let session = null;
        let localReferenceSpace = null;
        let viewerSpace = null;
        let gl = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let currentLocation = null;
        let waypoints = [];
        let waypointMarkers = [];
        
        const urlParams = new URLSearchParams(window.location.search);
        const routeId = urlParams.get('routeId');

        // Check AR capabilities
        async function checkARSupport() {
            if (!navigator.xr) {
                throw new Error('WebXR not supported in this browser');
            }

            const features = ['local'];
            const optionalFeatures = ['camera-access', 'geolocation', 'dom-overlay'];
            
            try {
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    throw new Error('AR not supported on this device');
                }

                // Check each feature individually
                const supportedFeatures = [];
                for (const feature of features) {
                    try {
                        const session = await navigator.xr.requestSession('immersive-ar', {
                            requiredFeatures: [feature]
                        });
                        supportedFeatures.push(feature);
                        await session.end();
                    } catch (e) {
                        console.warn(`Feature ${feature} not supported:`, e);
                    }
                }

                return {
                    supported: true,
                    features: supportedFeatures,
                    optionalFeatures: optionalFeatures
                };
            } catch (error) {
                throw new Error(`AR support check failed: ${error.message}`);
            }
        }

        // Initialize scene
        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 5, 5);
            scene.add(directionalLight);
        }

        // Initialize AR session with progressive enhancement
        async function initAR() {
            try {
                const arSupport = await checkARSupport();
                
                // Configure session with supported features
                const sessionInit = {
                    requiredFeatures: arSupport.features,
                    optionalFeatures: arSupport.optionalFeatures
                };

                if (arSupport.optionalFeatures.includes('dom-overlay')) {
                    sessionInit.domOverlay = { root: document.body };
                }

                session = await navigator.xr.requestSession('immersive-ar', sessionInit);

                // Set up GL context
                const canvas = document.querySelector('#ar-canvas');
                gl = canvas.getContext('webgl2', { xrCompatible: true });
                
                if (!gl) {
                    gl = canvas.getContext('webgl', { xrCompatible: true });
                }
                
                if (!gl) {
                    throw new Error('WebGL not supported');
                }

                // Initialize renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    context: gl,
                    alpha: true,
                    antialias: true
                });
                
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;

                initScene();

                // Set up reference spaces with fallbacks
                try {
                    localReferenceSpace = await session.requestReferenceSpace('local');
                } catch (e) {
                    console.warn('Local reference space not supported, falling back to viewer');
                    localReferenceSpace = await session.requestReferenceSpace('viewer');
                }

                viewerSpace = await session.requestReferenceSpace('viewer');

                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, gl)
                });

                await startLocationTracking();
                await loadWaypoints();

                session.requestAnimationFrame(onXRFrame);
                
                showMessage('AR Navigation Started');
                
            } catch (error) {
                console.error('AR initialization failed:', error);
                showError(`AR initialization failed: ${error.message}\nTrying fallback mode...`);
                document.getElementById('fallback-mode').style.display = 'block';
            }
        }

        // Create waypoint marker
        function createWaypointMarker(type) {
            const geometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 32);
            let material;
            
            switch(type) {
                case 'turn_warning':
                    material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                    break;
                case 'turn':
                    material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                    break;
                case 'destination':
                    material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                    break;
                default:
                    material = new THREE.MeshStandardMaterial({ color: 0x0000ff });
            }
            
            const marker = new THREE.Mesh(geometry, material);
            return marker;
        }

        // Update waypoint positions
        function updateWaypointPositions() {
            if (!currentLocation) return;

            waypointMarkers.forEach((marker, index) => {
                const waypoint = waypoints[index];
                if (!waypoint) return;

                // Calculate position relative to user
                const dx = (waypoint.lng - currentLocation.longitude) * 111320 * 
                    Math.cos(currentLocation.latitude * Math.PI / 180);
                const dy = (waypoint.lat - currentLocation.latitude) * 111320;

                // Update marker position
                marker.position.set(dx, 0, -dy);
                
                // Check distance to waypoint
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5) { // 5 meters threshold
                    handleWaypointReached(waypoint);
                }
            });
        }

        // Handle waypoint reached
        function handleWaypointReached(waypoint) {
            switch(waypoint.type) {
                case 'turn_warning':
                    showMessage(`Turn coming up in ${waypoint.distanceToTurn}m`);
                    break;
                case 'turn':
                    showMessage(`Turn ${waypoint.turnAngle > 0 ? 'right' : 'left'}`);
                    break;
                case 'destination_approach':
                    showMessage(`Destination in ${waypoint.distanceToDestination}m`);
                    break;
                case 'destination':
                    showMessage('You have reached your destination!');
                    break;
            }
        }

        // Show message in UI
        function showMessage(text) {
            const info = document.getElementById('info');
            info.textContent = text;
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Initialize AR session
        async function initAR() {
            if (!navigator.xr) {
                showError('WebXR not supported');
                return;
            }

            try {
                // Check if immersive-ar is supported
                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                if (!supported) {
                    showError('AR not supported');
                    return;
                }

                // Set up AR session
                session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['local', 'camera-access', 'geolocation'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                });

                // Set up GL context
                const canvas = document.querySelector('#ar-canvas');
                gl = canvas.getContext('webgl2', { xrCompatible: true });
                
                // Initialize Three.js renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    context: gl,
                    alpha: true,
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;

                // Initialize scene
                initScene();

                // Set up reference spaces
                localReferenceSpace = await session.requestReferenceSpace('local');
                viewerSpace = await session.requestReferenceSpace('viewer');

                // Start AR session
                session.updateRenderState({
                    baseLayer: new XRWebGLLayer(session, gl)
                });

                // Start render loop
                session.requestAnimationFrame(onXRFrame);

                // Start location tracking
                startLocationTracking();

                // Load waypoints
                await loadWaypoints();

            } catch (error) {
                console.error('Error initializing AR:', error);
                showError('Failed to start AR: ' + error.message);
            }
        }

        // Start location tracking
        function startLocationTracking() {
            if ('geolocation' in navigator) {
                navigator.geolocation.watchPosition(
                    position => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                        updateWaypointPositions();
                    },
                    error => {
                        console.error('Geolocation error:', error);
                        showError('Location tracking failed');
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    }
                );
            }
        }

        // Load waypoints from server
        async function loadWaypoints() {
            try {
                const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
                if (!response.ok) throw new Error('Failed to load waypoints');
                
                const data = await response.json();
                waypoints = data.waypoints;

                // Create markers for each waypoint
                waypoints.forEach(waypoint => {
                    const marker = createWaypointMarker(waypoint.type);
                    scene.add(marker);
                    waypointMarkers.push(marker);
                });

                showMessage('Navigation ready');
            } catch (error) {
                console.error('Error loading waypoints:', error);
                showError('Failed to load route data');
            }
        }

        // XR animation frame callback
        function onXRFrame(time, frame) {
            if (!session) return;

            session.requestAnimationFrame(onXRFrame);

            const pose = frame.getViewerPose(localReferenceSpace);
            if (!pose) return;

            const layer = session.renderState.baseLayer;
            renderer.setSize(layer.framebufferWidth, layer.framebufferHeight);

            camera.matrix.fromArray(pose.views[0].transform.matrix);
            camera.updateMatrixWorld(true);

            renderer.render(scene, camera);
        }

        // Initialize
        document.getElementById('start-button').addEventListener('click', initAR);
        document.getElementById('fallback-mode').addEventListener('click', initFallbackMode);
    </script>
</body>
</html>
