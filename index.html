<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Navigation - Revised</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
    #enter-ar { position: absolute; top: 10px; left: 10px; z-index: 999; padding: 12px 24px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
    #enter-ar:hover { background: #0056b3; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 8px; display: none; text-align: center; }
    #debug { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; font-size: 11px; border-radius: 4px; max-width: 80%; word-wrap: break-word; max-height: 300px; overflow-y: auto; }
    #orientation { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; font-size: 14px; border-radius: 4px; }
    #status { position: absolute; top: 60px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 8px; font-size: 12px; border-radius: 4px; }
  </style>
</head>
<body>
  <button id="enter-ar">Enter AR</button>
  <div id="loading">Initializing AR Navigation...</div>
  <div id="debug"></div>
  <div id="orientation"></div>
  <div id="status"></div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // UI elements
    const debug = document.getElementById('debug');
    const orientationDisplay = document.getElementById('orientation');
    const statusDisplay = document.getElementById('status');

    // Global state
    let userLocation = null;
    let userHeading = 0;
    let waypoints = [];
    let arObjects = [];
    let isARSessionActive = false;
    let hitTestSource = null;
    let reticle = null;
    let groundAnchor = null;

    function log(message) {
      console.log(message);
      const time = new Date().toLocaleTimeString();
      debug.innerHTML += `[${time}] ${message}<br>`;
      debug.scrollTop = debug.scrollHeight;
    }

    function updateStatus(message) {
      statusDisplay.textContent = message;
      statusDisplay.style.display = 'block';
    }

    // Enhanced lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 20, 10);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Create enhanced road arrow
    function createRoadArrow() {
      const group = new THREE.Group();
      
      // Main arrow body
      const arrowGeometry = new THREE.ConeGeometry(0.3, 1, 6);
      const arrowMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdd00,
        emissive: 0xffdd00,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.9
      });
      
      const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
      arrow.rotation.x = Math.PI / 2; // Point forward
      
      // Glow effect
      const glowGeometry = new THREE.ConeGeometry(0.4, 1.2, 6);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.rotation.x = Math.PI / 2;
      
      group.add(glow);
      group.add(arrow);
      group.position.y = 0.1; // Slightly above ground
      
      return group;
    }

    // Create enhanced destination marker
    function createDestinationMarker() {
      const group = new THREE.Group();
      
      // Pin body
      const pinGeometry = new THREE.CylinderGeometry(0.2, 0.15, 1.2, 8);
      const pinMaterial = new THREE.MeshStandardMaterial({
        color: 0xcc0000,
        emissive: 0x440000,
        emissiveIntensity: 0.3,
        metalness: 0.3,
        roughness: 0.4
      });
      
      const pin = new THREE.Mesh(pinGeometry, pinMaterial);
      pin.position.y = 0.6;
      
      // Pin point
      const pointGeometry = new THREE.ConeGeometry(0.15, 0.4, 8);
      const point = new THREE.Mesh(pointGeometry, pinMaterial);
      point.position.y = -0.1;
      
      // Flag
      const flagGeometry = new THREE.PlaneGeometry(0.8, 0.5);
      const flagMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0x220000,
        emissiveIntensity: 0.2,
        side: THREE.DoubleSide
      });
      const flag = new THREE.Mesh(flagGeometry, flagMaterial);
      flag.position.set(0.4, 1, 0);
      
      group.add(pin);
      group.add(point);
      group.add(flag);
      group.position.y = 1.5; // Elevated for visibility
      
      return group;
    }

    // Improved distance calculation with validation
    function calculateDistance(lat1, lon1, lat2, lon2) {
      if (!lat1 || !lon1 || !lat2 || !lon2) return Infinity;
      
      const R = 6371000; // Earth's radius in meters
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
               Math.cos(φ1) * Math.cos(φ2) *
               Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      
      return R * c;
    }

    // Calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;
      
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      
      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    // Convert GPS to local AR coordinates (relative to user position)
    function gpsToLocalCoordinates(targetLat, targetLng, userLat, userLng, userHeading = 0) {
      const distance = calculateDistance(userLat, userLng, targetLat, targetLng);
      const bearing = calculateBearing(userLat, userLng, targetLat, targetLng);
      
      // Adjust bearing relative to user's heading
      const relativeBearing = (bearing - userHeading) * Math.PI / 180;
      
      // Convert to local coordinates (forward = -z, right = +x)
      const x = distance * Math.sin(relativeBearing);
      const z = -distance * Math.cos(relativeBearing);
      
      return { x, z, distance, bearing };
    }

    // Start GPS tracking
    function startLocationTracking() {
      if (!navigator.geolocation) {
        log("Geolocation not supported");
        updateStatus("Location services not available");
        return false;
      }

      const options = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 2000
      };

      navigator.geolocation.watchPosition(
        (position) => {
          userLocation = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: Date.now()
          };
          
          log(`GPS: ${userLocation.lat.toFixed(6)}, ${userLocation.lng.toFixed(6)} (±${userLocation.accuracy.toFixed(1)}m)`);
          updateStatus(`GPS: ±${userLocation.accuracy.toFixed(1)}m accuracy`);
          
          if (isARSessionActive) {
            updateARObjects();
          }
        },
        (error) => {
          log(`GPS Error: ${error.message}`);
          updateStatus(`GPS Error: ${error.message}`);
        },
        options
      );

      return true;
    }

    // Start device orientation tracking
    function startOrientationTracking() {
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', (event) => {
          if (event.alpha !== null) {
            userHeading = event.alpha;
            orientationDisplay.textContent = `Heading: ${Math.round(userHeading)}°`;
            orientationDisplay.style.display = 'block';
            
            if (isARSessionActive && userLocation) {
              updateARObjects();
            }
          }
        });
        return true;
      }
      return false;
    }

    // Update AR objects based on current user position and heading
    function updateARObjects() {
      if (!userLocation || !waypoints.length || !groundAnchor) return;
      
      // Clear existing AR objects
      arObjects.forEach(obj => scene.remove(obj));
      arObjects = [];
      
      // Process waypoints
      waypoints.forEach((waypoint, index) => {
        const coords = gpsToLocalCoordinates(
          waypoint.lat, waypoint.lng,
          userLocation.lat, userLocation.lng,
          userHeading
        );
        
        // Only show objects within reasonable range (200m)
        if (coords.distance > 200) return;
        
        // Scale factor: 1 meter = 1 unit (true scale)
        const scale = 1.0;
        
        if (index === waypoints.length - 1) {
          // Final destination
          const marker = createDestinationMarker();
          marker.position.copy(groundAnchor.position);
          marker.position.x += coords.x * scale;
          marker.position.z += coords.z * scale;
          arObjects.push(marker);
          scene.add(marker);
          
          log(`Destination: ${coords.distance.toFixed(1)}m at ${coords.bearing.toFixed(0)}°`);
        } else if (index > 0) {
          // Navigation arrows
          const arrow = createRoadArrow();
          arrow.position.copy(groundAnchor.position);
          arrow.position.x += coords.x * scale;
          arrow.position.z += coords.z * scale;
          
          // Point arrow toward next waypoint
          if (index < waypoints.length - 1) {
            const nextCoords = gpsToLocalCoordinates(
              waypoints[index + 1].lat, waypoints[index + 1].lng,
              waypoint.lat, waypoint.lng,
              userHeading
            );
            arrow.rotation.y = Math.atan2(nextCoords.x, -nextCoords.z);
          }
          
          arObjects.push(arrow);
          scene.add(arrow);
        }
      });
      
      log(`Updated ${arObjects.length} AR objects`);
    }

    // Load waypoints from server
    async function loadWaypoints() {
      const routeId = new URLSearchParams(window.location.search).get('routeId');
      if (!routeId) {
        throw new Error("No route ID provided in URL");
      }
      
      try {
        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        if (!data.waypoints || !data.waypoints.length) {
          throw new Error("No waypoints received from server");
        }
        
        // Filter and validate waypoints
        const validWaypoints = data.waypoints.filter(wp => 
          wp.lat && wp.lng && 
          Math.abs(wp.lat) <= 90 && 
          Math.abs(wp.lng) <= 180
        );
        
        if (!validWaypoints.length) {
          throw new Error("No valid waypoints found");
        }
        
        log(`Loaded ${validWaypoints.length} valid waypoints`);
        return validWaypoints;
        
      } catch (error) {
        log(`Waypoint loading error: ${error.message}`);
        throw error;
      }
    }

    // Initialize AR session
    async function startAR() {
      try {
        // Check WebXR support
        if (!('xr' in navigator)) {
          throw new Error("WebXR not supported on this browser");
        }
        
        const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!isSupported) {
          throw new Error("AR not supported on this device");
        }
        
        // Create reticle for ground detection
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true })
        );
        reticle.visible = false;
        scene.add(reticle);
        
        // Create AR button
        const arButton = ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        document.body.appendChild(arButton);
        
        // Session event handlers
        renderer.xr.addEventListener('sessionstart', () => {
          log('AR session started');
          isARSessionActive = true;
          updateStatus('AR Active - Looking for ground...');
        });
        
        renderer.xr.addEventListener('sessionend', () => {
          log('AR session ended');
          isARSessionActive = false;
          hitTestSource = null;
          groundAnchor = null;
          updateStatus('AR Session Ended');
        });
        
        // Main render loop
        let hitTestRequested = false;
        
        renderer.setAnimationLoop((timestamp, frame) => {
          if (frame) {
            const session = renderer.xr.getSession();
            
            // Request hit test source
            if (!hitTestRequested) {
              session.requestReferenceSpace('viewer').then((referenceSpace) => {
                session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                  hitTestSource = source;
                  log('Hit test source acquired');
                });
              });
              hitTestRequested = true;
            }
            
            // Perform hit testing
            if (hitTestSource) {
              const hitTestResults = frame.getHitTestResults(hitTestSource);
              
              if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const referenceSpace = renderer.xr.getReferenceSpace();
                const pose = hit.getPose(referenceSpace);
                
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
                
                // Set ground anchor on first hit
                if (!groundAnchor && userLocation) {
                  groundAnchor = new THREE.Object3D();
                  groundAnchor.matrix.fromArray(pose.transform.matrix);
                  groundAnchor.matrix.decompose(groundAnchor.position, groundAnchor.quaternion, groundAnchor.scale);
                  scene.add(groundAnchor);
                  
                  log('Ground anchor established');
                  updateStatus('Ground detected - Placing navigation');
                  updateARObjects();
                }
              } else {
                reticle.visible = false;
              }
            }
          }
          
          renderer.render(scene, camera);
        });
        
        log('AR system initialized');
        
      } catch (error) {
        log(`AR initialization error: ${error.message}`);
        updateStatus(`AR Error: ${error.message}`);
        throw error;
      }
    }

    // Initialize everything
    async function initialize() {
      try {
        document.getElementById('loading').style.display = 'block';
        updateStatus('Initializing...');
        
        // Start location services
        if (!startLocationTracking()) {
          throw new Error("Could not start location tracking");
        }
        
        // Start orientation tracking
        if (!startOrientationTracking()) {
          log('Device orientation not available');
        }
        
        // Load waypoints
        waypoints = await loadWaypoints();
        
        // Initialize AR
        await startAR();
        
        log('System initialized successfully');
        updateStatus('Ready - Tap "Enter AR"');
        
      } catch (error) {
        log(`Initialization error: ${error.message}`);
        updateStatus(`Error: ${error.message}`);
        document.getElementById('loading').textContent = `Error: ${error.message}`;
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    // Event listeners
    document.getElementById("enter-ar").addEventListener("click", async () => {
      document.getElementById("enter-ar").style.display = "none";
      if (!waypoints.length) {
        await initialize();
      }
    });

    window.addEventListener("resize", () => {
      if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // Initialize on load
    log('AR Navigation system loading...');
    
  </script>
</body>
</html>
