<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced WebXR Outdoor Navigation</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #enter-ar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      padding: 12px 24px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    #enter-ar:hover {
      background: #0056b3;
    }
    #status {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 1000;
      display: none;
    }
    #compass {
      position: absolute;
      top: 70px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 50%;
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      z-index: 1000;
    }
    #compass::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 40px;
      background: red;
      transform-origin: bottom;
    }
    #debug {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 4px;
      font-size: 14px;
      max-width: 80%;
      z-index: 1000;
      display: none;
    }
  </style>
</head>
<body>
  <button id="enter-ar">Start AR Navigation</button>
  <div id="status">Initializing...</div>
  <div id="compass"></div>
  <div id="debug"></div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    class ARNavigator {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          logarithmicDepthBuffer: true
        });

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.xr.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        this.setupLighting();
        this.setupUI();
        this.setupEventListeners();
        
        this.currentPosition = null;
        this.currentOrientation = null;
        this.waypoints = [];
        this.navigationElements = new THREE.Group();
        this.scene.add(this.navigationElements);

        // Add timing for smooth updates
        this.lastUpdate = 0;
        this.updateInterval = 100; // Update every 100ms
      }

      setupUI() {
        this.debug = document.getElementById('debug');
        this.status = document.getElementById('status');
        this.compass = document.getElementById('compass');
      }

      setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        this.scene.add(ambientLight);
        this.scene.add(directionalLight);
      }

      setupEventListeners() {
        window.addEventListener('resize', () => {
          if (!this.renderer.xr.isPresenting) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          }
        });
      }

      async initialize() {
        try {
          await this.requestPermissions();
          await this.setupGeolocation();
          await this.setupOrientation();
          await this.loadWaypoints();
          this.startARSession();
        } catch (error) {
          this.showError(`Initialization failed: ${error.message}`);
        }
      }

      async requestPermissions() {
        this.updateStatus('Requesting permissions...');
        
        // Request location permission
        if (!('geolocation' in navigator)) {
          throw new Error('Geolocation not supported');
        }

        // Request device orientation permission on iOS
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') {
            throw new Error('Orientation permission denied');
          }
        }
      }

      async setupGeolocation() {
        this.updateStatus('Setting up location tracking...');
        
        return new Promise((resolve, reject) => {
          this.watchId = navigator.geolocation.watchPosition(
            (position) => {
              this.currentPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
              };
              this.log(`Position updated: ${position.coords.latitude}, ${position.coords.longitude}`);
              this.updateNavigation();
              resolve();
            },
            (error) => reject(`Geolocation error: ${error.message}`),
            {
              enableHighAccuracy: true,
              maximumAge: 0,
              timeout: 5000
            }
          );
        });
      }

      setupOrientation() {
        this.updateStatus('Setting up orientation tracking...');
        
        return new Promise((resolve) => {
          const handleOrientation = (event) => {
            const now = Date.now();
            if (now - this.lastUpdate < this.updateInterval) return;
            this.lastUpdate = now;

            if (event.absolute || 'webkitCompassHeading' in event) {
              this.currentOrientation = {
                alpha: event.webkitCompassHeading || event.alpha,
                beta: event.beta,
                gamma: event.gamma,
                absolute: true
              };
            } else {
              this.currentOrientation = {
                alpha: event.alpha,
                beta: event.beta,
                gamma: event.gamma,
                absolute: false
              };
              this.log('Using relative orientation');
            }

            // Update compass display
            this.updateCompassDisplay();
            this.updateNavigation();
          };

          if ('ondeviceorientationabsolute' in window) {
            window.addEventListener('deviceorientationabsolute', handleOrientation);
            this.log('Using absolute orientation');
          } else {
            window.addEventListener('deviceorientation', handleOrientation);
            this.log('Using standard orientation');
          }
          
          resolve();
        });
      }

      updateCompassDisplay() {
        if (!this.currentOrientation) return;
        
        const heading = this.currentOrientation.alpha;
        this.compass.style.display = 'block';
        this.compass.textContent = `${Math.round(heading)}°`;
        this.compass.style.setProperty('--rotation', `${heading}deg`);
        this.compass.querySelector('::after').style.transform = `rotate(${heading}deg)`;
      }

      async loadWaypoints() {
        this.updateStatus('Loading route...');
        
        const routeId = new URLSearchParams(window.location.search).get('routeId');
        if (!routeId) {
          throw new Error('No route ID provided');
        }

        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        const data = await response.json();
        this.waypoints = data.waypoints || [];
        
        if (this.waypoints.length === 0) {
          throw new Error('No waypoints found');
        }

        this.log(`Loaded ${this.waypoints.length} waypoints`);
      }

      createArrow() {
        const arrow = new THREE.Group();

        // Create arrow body
        const bodyGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.05);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x2196F3,
          metalness: 0.3,
          roughness: 0.4
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = -0.2;
        arrow.add(body);

        // Create arrow head
        const headGeometry = new THREE.ConeGeometry(0.15, 0.3, 32);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.rotation.z = Math.PI;
        arrow.add(head);

        // Add glow effect
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x64B5F6,
          transparent: true,
          opacity: 0.5
        });
        
        const glowBody = new THREE.Mesh(bodyGeometry, glowMaterial);
        const glowHead = new THREE.Mesh(headGeometry, glowMaterial);
        glowBody.scale.multiplyScalar(1.2);
        glowHead.scale.multiplyScalar(1.2);
        glowBody.position.copy(body.position);
        glowHead.rotation.copy(head.rotation);
        
        arrow.add(glowBody);
        arrow.add(glowHead);

        return arrow;
      }

      createLabel(text, isDebug = false) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = isDebug ? 512 : 256;
        canvas.height = isDebug ? 256 : 128;

        if (isDebug) {
          context.fillStyle = 'rgba(0, 0, 0, 0.8)';
          context.fillRect(0, 0, canvas.width, canvas.height);
        }

        context.fillStyle = 'white';
        context.font = isDebug ? '24px Arial' : '48px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';

        if (isDebug) {
          const lines = text.split('\n');
          lines.forEach((line, i) => {
            context.fillText(line, canvas.width / 2, 60 + i * 30);
          });
        } else {
          context.fillText(text, canvas.width / 2, canvas.height / 2);
        }

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(isDebug ? 1 : 0.5, isDebug ? 0.5 : 0.25, 1);

        return sprite;
      }

      updateNavigation() {
        if (!this.currentPosition || !this.currentOrientation) {
          this.updateStatus('Waiting for location and orientation...');
          return;
        }

        // Clear existing elements
        while (this.navigationElements.children.length > 0) {
          this.navigationElements.remove(this.navigationElements.children[0]);
        }

        // Find closest waypoint
        const closestWaypoint = this.findClosestWaypoint();
        if (!closestWaypoint) {
          this.updateStatus('No waypoint found');
          return;
        }

        // Calculate bearing to waypoint
        const targetBearing = this.calculateBearing(
          this.currentPosition.lat,
          this.currentPosition.lng,
          closestWaypoint.lat,
          closestWaypoint.lng
        );

        // Get device compass heading
        let deviceHeading = this.currentOrientation.alpha || 0;
        deviceHeading = (360 - deviceHeading) % 360;

        // Calculate relative angle
        let relativeAngle = (targetBearing - deviceHeading + 360) % 360;
        const angleInRadians = (relativeAngle * Math.PI) / 180;

        // Create arrow group
        const arrowGroup = new THREE.Group();
        
        // Add main arrow
        const arrow = this.createArrow();
        arrow.rotation.set(0, angleInRadians, 0);
        arrowGroup.add(arrow);

        // Add distance label
        const distance = this.calculateDistance(closestWaypoint);
        const distanceLabel = this.createLabel(`${Math.round(distance)}m`);
        distanceLabel.position.y = 0.3;
        arrowGroup.add(distanceLabel);

        // Add debug label
        const debugInfo = 
          `Target: ${Math.round(targetBearing)}°\n` +
          `Device: ${Math.round(deviceHeading)}°\n` +
          `Relative: ${Math.round(relativeAngle)}°`;
        const debugLabel = this.createLabel(debugInfo, true);
        debugLabel.position.y = -0.3;
        arrowGroup.add(debugLabel);

        // Position the entire group
        arrowGroup.position.set(0, 1.6, -2);
        this.navigationElements.add(arrowGroup);

        // Update status
        this.updateStatus(
          `Distance: ${Math.round(distance)}m | ` +
          `Bearing: ${Math.round(targetBearing)}° | ` +
          `Heading: ${Math.round(deviceHeading)}°`
        );
      }

      calculateDistance(waypoint) {
        const R = 6371000; // Earth's radius in meters
        const φ1 = this.currentPosition.lat * Math.PI / 180;
        const φ2 = waypoint.lat * Math.PI / 180;
        const Δφ = (waypoint.lat - this.currentPosition.lat) * Math.PI / 180;
        const Δλ = (waypoint.lng - this.currentPosition.lng) * Math.PI / 180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
      }

      calculateBearing(lat1, lon1, lat2, lon2) {
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const λ1 = lon1 * Math.PI / 180;
        const λ2 = lon2 * Math.PI / 180;

        const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) -
                 Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);

        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
      }

      findClosestWaypoint() {
        if (!this.waypoints.length) return null;

        let closest = null;
        let minDistance = Infinity;

        for (const waypoint of this.waypoints) {
          if (!waypoint.lat || !waypoint.lng) continue;
          
          const distance = this.calculateDistance(waypoint);
          if (distance < minDistance) {
            minDistance = distance;
            closest = waypoint;
          }
        }

        return closest;
      }

      async startARSession() {
        this.updateStatus('Starting AR...');
        
        try {
          const arButton = ARButton.createButton(this.renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          });
          document.body.appendChild(arButton);

          this.renderer.setAnimationLoop(() => {
            this.renderer.render(this.scene, this.camera);
          });
        } catch (error) {
          this.showError(`AR session failed: ${error.message}`);
        }
      }

      updateStatus(message) {
        this.status.textContent = message;
        this.status.style.display = 'block';
      }

      showError(message) {
        this.updateStatus(`Error: ${message}`);
        console.error(message);
      }

      log(message) {
        console.log(message);
        this.debug.textContent += `${message}\n`;
        this.debug.style.display = 'block';
      }

      dispose() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
        }
        this.renderer.dispose();
      }
    }

    // Initialize the application
    const arNavigator = new ARNavigator();
    
    document.getElementById('enter-ar').addEventListener('click', async () => {
      try {
        document.getElementById('enter-ar').style.display = 'none';
        await arNavigator.initialize();
      } catch (error) {
        console.error('Failed to initialize AR:', error);
        alert(`Failed to start AR: ${error.message}`);
      }
    });
  </script>
</body>
</html>
