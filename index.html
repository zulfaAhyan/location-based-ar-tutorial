<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Outdoor Navigation</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
            }
        }
    </script>
    <style>
        #status-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">
    <button id="enter-ar" style="position: absolute; top: 10px; left: 10px; z-index: 999;">Enter AR</button>
    <div id="status-message"></div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            logarithmicDepthBuffer: true
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        async function loadWaypoints() {
            const routeId = new URLSearchParams(window.location.search).get('routeId') || '12345';
            try {
                const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints?routeId=${routeId}`);
                const data = await response.json();
                console.log("Loaded waypoints:", data);
                return data;
            } catch (error) {
                console.error("Error fetching waypoints:", error);
                return [];
            }
        }

        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            });
        }

        function calculateRelativePosition(currentLat, currentLon, targetLat, targetLon) {
            const R = 6371000; // Earth's radius in meters
            const φ1 = currentLat * Math.PI / 180;
            const φ2 = targetLat * Math.PI / 180;
            const Δφ = (targetLat - currentLat) * Math.PI / 180;
            const Δλ = (targetLon - currentLon) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c;

            // Calculate bearing
            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                    Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
            const bearing = Math.atan2(y, x);

            // Convert to cartesian coordinates
            // Use a more reasonable scale factor (1 unit = 10 meters)
            const scale = 0.1; // This makes 1 THREE.js unit = 10 meters
            return {
                x: Math.sin(bearing) * distance * scale,
                z: Math.cos(bearing) * distance * scale,
                distance: distance
            };
        }

        function createWaypointMarker(position, color, distance) {
            const group = new THREE.Group();

            // Create floating arrow marker
            const arrowGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
            const arrowMaterial = new THREE.MeshStandardMaterial({ color });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.rotation.x = Math.PI;
            arrow.position.y = 2;
            group.add(arrow);

            // Add beacon light
            const beaconGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const beaconMaterial = new THREE.MeshStandardMaterial({
                color: 'white',
                emissive: color,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.y = 2;
            group.add(beacon);

            // Add distance label
            const distanceInMeters = Math.round(distance);
            showMessage(`Waypoint distance: ${distanceInMeters}m`);

            // Position the group
            group.position.set(position.x, 0, position.z);
            scene.add(group);

            // Animate beacon
            function animate() {
                beacon.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.1;
                arrow.position.y = beacon.position.y + 0.3;
                requestAnimationFrame(animate);
            }
            animate();

            return group;
        }

        function showMessage(text) {
            const message = document.getElementById('status-message');
            message.textContent = text;
            message.style.display = 'block';
        }

        async function initAR() {
            try {
                const currentPosition = await getCurrentPosition();
                const waypoints = await loadWaypoints();
                
                if (waypoints.length === 0) {
                    throw new Error("No waypoints found");
                }

                waypoints.forEach((waypoint, index) => {
                    if (waypoint.lat && waypoint.lng) {
                        const position = calculateRelativePosition(
                            currentPosition.coords.latitude,
                            currentPosition.coords.longitude,
                            waypoint.lat,
                            waypoint.lng
                        );

                        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
                        createWaypointMarker(position, colors[index % colors.length], position.distance);
                    }
                });

                const arButton = ARButton.createButton(renderer, {
                    requiredFeatures: ['hit-test'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                });
                document.body.appendChild(arButton);

                renderer.setAnimationLoop(() => {
                    renderer.render(scene, camera);
                });

            } catch (error) {
                showMessage(`Error: ${error.message}`);
                console.error(error);
            }
        }

        document.getElementById('enter-ar').addEventListener('click', () => {
            initAR();
            document.getElementById('enter-ar').style.display = 'none';
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
