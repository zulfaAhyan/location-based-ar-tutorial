<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Improved WebXR Navigation</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    let scene, camera, renderer, userGroup;
    const waypoints = [];

    async function fetchWaypoints(routeId) {
      try {
        const response = await fetch(`https://waypoints-prht.onrender.com/get-waypoints/${routeId}`);
        const data = await response.json();
        console.log("Loaded waypoints:", data);
        return data;
      } catch (error) {
        console.error("Error fetching waypoints:", error);
        return [];
      }
    }

    function calculatePosition(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const x = R * Δλ * Math.cos((φ1 + φ2) / 2);
      const z = R * Δφ;
      return { x, z };
    }

    function createMarker(position, color, label = "") {
      const markerGroup = new THREE.Group();

      const markerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
      const markerMaterial = new THREE.MeshStandardMaterial({ color });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.set(0, 1, 0);
      markerGroup.add(marker);

      if (label) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 64;
        const context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.font = '28px Arial';
        context.fillText(label, 10, 40);

        const texture = new THREE.CanvasTexture(canvas);
        const labelMaterial = new THREE.SpriteMaterial({ map: texture });
        const labelSprite = new THREE.Sprite(labelMaterial);
        labelSprite.position.set(0, 2.5, 0);
        labelSprite.scale.set(2, 1, 1);
        markerGroup.add(labelSprite);
      }

      markerGroup.position.set(position.x, 0, position.z);
      scene.add(markerGroup);
      return markerGroup;
    }

    function updateUserPosition(latitude, longitude, heading) {
      if (waypoints.length === 0) return;

      const firstWaypoint = waypoints[0];
      const { x, z } = calculatePosition(firstWaypoint.lat, firstWaypoint.lng, latitude, longitude);

      userGroup.position.set(x, 0, z);
      userGroup.rotation.y = THREE.Math.degToRad(-heading);
    }

    async function initWaypoints(routeId) {
      const waypointData = await fetchWaypoints(routeId);
      if (waypointData.length === 0) return;

      const firstWaypoint = waypointData[0];
      waypointData.forEach((wp, index) => {
        if (wp.lat && wp.lng) {
          const { x, z } = calculatePosition(firstWaypoint.lat, firstWaypoint.lng, wp.lat, wp.lng);
          waypoints.push(wp);
          createMarker({ x, z }, index === waypointData.length - 1 ? 'green' : 'red', `Point ${index + 1}`);
        }
      });
    }

    async function startAR() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      userGroup = new THREE.Group();
      scene.add(userGroup);

      const arButton = ARButton.createButton(renderer, {
        requiredFeatures: ['local-floor']
      });
      document.body.appendChild(arButton);

      const routeId = new URLSearchParams(window.location.search).get('routeId');
      if (routeId) await initWaypoints(routeId);

      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(position => {
          const { latitude, longitude } = position.coords;
          const heading = 0; // Replace with device heading if available
          updateUserPosition(latitude, longitude, heading);
        }, error => console.error(error), { enableHighAccuracy: true });
      }

      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    }

    document.getElementById('start-ar').addEventListener('click', startAR);

    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</head>
<body style="margin: 0; overflow: hidden;">
  <button id="start-ar" style="position: absolute; top: 10px; left: 10px; z-index: 999;">Start AR</button>
</body>
</html>
