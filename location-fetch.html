<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Surface Navigation</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000;
    }
    #start-ar {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 999;
      padding: 16px 32px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(0,123,255,0.3);
      transition: all 0.3s ease;
    }
    #start-ar:hover {
      background: #0056b3;
      transform: translate(-50%, -50%) scale(1.05);
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: none;
      gap: 10px;
      flex-wrap: wrap;
    }
    .control-btn {
      padding: 10px 20px;
      background: rgba(0,123,255,0.8);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      font-size: 14px;
    }
    .control-btn:hover {
      background: rgba(0,86,179,0.9);
    }
    .control-btn.active {
      background: rgba(0,255,0,0.8);
    }
    #status {
      position: absolute;
      top: 80px;
      left: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 6px;
      text-align: center;
      backdrop-filter: blur(10px);
      display: none;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <button id="start-ar">Start AR Navigation</button>
  
  <div id="controls">
    <button class="control-btn" id="place-path">Place Navigation Path</button>
    <button class="control-btn" id="clear-path">Clear Path</button>
    <button class="control-btn" id="toggle-mode">Mode: Auto</button>
  </div>
  
  <div id="status">Point device at ground to detect surface</div>
  
  <div id="instructions">
    <strong>AR Navigation Ready!</strong><br>
    Tap "Place Navigation Path" to start placing arrows on detected surfaces.<br>
    Walk around and tap to create your navigation route.
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // UI Elements
    const startBtn = document.getElementById('start-ar');
    const controlsDiv = document.getElementById('controls');
    const instructionsDiv = document.getElementById('instructions');
    const statusDiv = document.getElementById('status');
    const placePathBtn = document.getElementById('place-path');
    const clearPathBtn = document.getElementById('clear-path');
    const toggleModeBtn = document.getElementById('toggle-mode');

    // Lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 10, 0);
    scene.add(directionalLight);

    // Navigation state
    let navigationArrows = [];
    let isPlacingPath = false;
    let autoMode = true;
    let lastArrowPosition = null;
    const minArrowDistance = 2; // Minimum distance between arrows in meters

    // Hit testing variables
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let reticle = null;

    // Create yellow chevron arrow
    function createNavArrow() {
      const shape = new THREE.Shape();
      shape.moveTo(-0.5, -0.5);
      shape.lineTo(0, 0.5);
      shape.lineTo(0.5, -0.5);
      shape.lineTo(-0.5, -0.5);
      
      const geometry = new THREE.ShapeGeometry(shape);
      const material = new THREE.MeshStandardMaterial({ 
        color: 0xffff00,
        transparent: true,
        opacity: 0.9,
        emissive: 0xffff00,
        emissiveIntensity: 0.5,
        side: THREE.DoubleSide
      });
      
      const arrow = new THREE.Mesh(geometry, material);
      arrow.rotation.x = -Math.PI / 2; // Lay flat on ground
      arrow.scale.set(0.4, 0.4, 0.4);
      
      return arrow;
    }

    // Create surface detection reticle
    function createReticle() {
      const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
      const material = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.8
      });
      
      const reticle = new THREE.Mesh(geometry, material);
      reticle.visible = false;
      return reticle;
    }

    // Calculate distance between two points
    function calculateDistance(pos1, pos2) {
      return Math.sqrt(
        Math.pow(pos1.x - pos2.x, 2) + 
        Math.pow(pos1.y - pos2.y, 2) + 
        Math.pow(pos1.z - pos2.z, 2)
      );
    }

    // Calculate direction from one point to another
    function calculateDirection(from, to) {
      const direction = new THREE.Vector3();
      direction.subVectors(to, from);
      direction.y = 0; // Keep horizontal
      direction.normalize();
      return Math.atan2(direction.x, direction.z);
    }

    // Place arrow at hit test result
    function placeArrow(hitResult, referenceSpace) {
      const pose = hitResult.getPose(referenceSpace);
      const position = new THREE.Vector3(
        pose.transform.position.x,
        pose.transform.position.y + 0.01, // Slightly above surface
        pose.transform.position.z
      );

      // Check minimum distance from last arrow
      if (lastArrowPosition && calculateDistance(position, lastArrowPosition) < minArrowDistance) {
        statusDiv.textContent = `Move at least ${minArrowDistance}m from last arrow`;
        return;
      }

      const arrow = createNavArrow();
      arrow.position.copy(position);

      // If we have a previous arrow, point this one toward it or away from it
      if (navigationArrows.length > 0 && autoMode) {
        const previousArrow = navigationArrows[navigationArrows.length - 1];
        const direction = calculateDirection(previousArrow.position, position);
        arrow.rotation.y = direction;
      }

      scene.add(arrow);
      navigationArrows.push(arrow);
      lastArrowPosition = position.clone();

      statusDiv.textContent = `Arrow ${navigationArrows.length} placed`;
      
      // Auto-connect arrows if we have multiple
      if (navigationArrows.length > 1 && autoMode) {
        connectArrows();
      }
    }

    // Connect arrows to create a path
    function connectArrows() {
      for (let i = 0; i < navigationArrows.length - 1; i++) {
        const currentArrow = navigationArrows[i];
        const nextArrow = navigationArrows[i + 1];
        
        // Point current arrow toward next arrow
        const direction = calculateDirection(currentArrow.position, nextArrow.position);
        currentArrow.rotation.y = direction;
      }
    }

    // Clear all navigation arrows
    function clearPath() {
      navigationArrows.forEach(arrow => {
        scene.remove(arrow);
      });
      navigationArrows = [];
      lastArrowPosition = null;
      statusDiv.textContent = "Path cleared";
    }

    // Create predefined demo path
    function createDemoPath() {
      const demoPositions = [
        new THREE.Vector3(0, 0.01, -2),
        new THREE.Vector3(1, 0.01, -3),
        new THREE.Vector3(2, 0.01, -2),
        new THREE.Vector3(3, 0.01, -4),
        new THREE.Vector3(2, 0.01, -5)
      ];

      demoPositions.forEach((pos, index) => {
        const arrow = createNavArrow();
        arrow.position.copy(pos);
        
        // Point each arrow to the next one
        if (index < demoPositions.length - 1) {
          const nextPos = demoPositions[index + 1];
          const direction = calculateDirection(pos, nextPos);
          arrow.rotation.y = direction;
        }
        
        scene.add(arrow);
        navigationArrows.push(arrow);
      });

      statusDiv.textContent = `Demo path created with ${navigationArrows.length} arrows`;
    }

    // Handle screen tap for placing arrows
    function onSelect() {
      if (isPlacingPath && reticle && reticle.visible) {
        const session = renderer.xr.getSession();
        const referenceSpace = renderer.xr.getReferenceSpace();
        
        // Get the latest hit test results
        const frame = session.requestAnimationFrame ? session : null;
        if (frame && hitTestSource) {
          session.requestAnimationFrame((timestamp, frame) => {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              placeArrow(hitTestResults[0], referenceSpace);
            }
          });
        }
      }
    }

    // AR Session setup
    async function startARSession() {
      try {
        if (!('xr' in navigator)) {
          throw new Error("WebXR not supported");
        }

        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          throw new Error("AR not supported");
        }

        statusDiv.textContent = "Starting AR session...";
        statusDiv.style.display = 'block';

        const session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });

        renderer.xr.setSession(session);

        // Create reticle for surface detection
        reticle = createReticle();
        scene.add(reticle);

        // Show controls
        controlsDiv.style.display = 'flex';
        instructionsDiv.style.display = 'block';
        startBtn.style.display = 'none';

        // Setup hit testing
        session.addEventListener('select', onSelect);

        session.addEventListener('end', () => {
          hitTestSourceRequested = false;
          hitTestSource = null;
          controlsDiv.style.display = 'none';
          instructionsDiv.style.display = 'none';
          statusDiv.style.display = 'none';
          startBtn.style.display = 'block';
        });

        statusDiv.textContent = "AR session started - Point at ground to detect surface";

      } catch (error) {
        statusDiv.textContent = `AR Error: ${error.message}`;
        statusDiv.style.display = 'block';
        console.error('AR Error:', error);
      }
    }

    // Event listeners
    startBtn.addEventListener('click', startARSession);

    placePathBtn.addEventListener('click', () => {
      isPlacingPath = !isPlacingPath;
      placePathBtn.textContent = isPlacingPath ? 'Stop Placing' : 'Place Navigation Path';
      placePathBtn.classList.toggle('active', isPlacingPath);
      
      if (isPlacingPath) {
        statusDiv.textContent = "Tap on detected surfaces to place arrows";
      } else {
        statusDiv.textContent = "Path placement stopped";
      }
    });

    clearPathBtn.addEventListener('click', clearPath);

    toggleModeBtn.addEventListener('click', () => {
      autoMode = !autoMode;
      toggleModeBtn.textContent = `Mode: ${autoMode ? 'Auto' : 'Manual'}`;
      statusDiv.textContent = `Switched to ${autoMode ? 'auto-connect' : 'manual'} mode`;
    });

    // Render loop with hit testing
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        // Setup hit test source
        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((referenceSpace) => {
            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          
          hitTestSourceRequested = true;
        }

        // Perform hit testing
        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          
          if (hitTestResults.length > 0 && reticle) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
            
            if (statusDiv.textContent === "Point device at ground to detect surface") {
              statusDiv.textContent = "Surface detected! Ready to place arrows";
            }
          } else if (reticle) {
            reticle.visible = false;
          }
        }
      }
      
      renderer.render(scene, camera);
    });

    // Handle window resize
    window.addEventListener("resize", () => {
      if (!renderer.xr.isPresenting) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>
