<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation System</title>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { 
            width: 100%; 
            height: 100%; 
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 5;
            pointer-events: none;
        }

        .ar-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            transform-origin: center;
        }

        .ar-arrow-head {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid rgba(33, 150, 243, 0.9);
            position: absolute;
            left: 50%;
            transform: translateX(-50%) rotateX(60deg);
        }

        .debug-info {
            position: fixed;
            bottom: 45%;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="camera-view">
        <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
            <a-camera gps-camera rotation-reader></a-camera>
        </a-scene>
    </div>

    <div class="ar-overlay">
        <div class="ar-arrow" id="navigation-arrow">
            <div class="ar-arrow-head"></div>
        </div>
    </div>

    <div class="map-view">
        <div id="map"></div>
    </div>

    <div class="controls">
        <input type="text" id="destination" placeholder="Enter your destination">
        <button onclick="startNavigation()">Navigate</button>
    </div>

    <div id="debug-info" class="debug-info"></div>

    <script>
        // Global variables
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;
        let currentRouteIndex = 0;
        let deviceCompassHeading = null;
        let isNavigating = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 100;

        // Initialize app
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await requestPermissions();
                const position = await getCurrentPosition();
                userLocation = [position.coords.latitude, position.coords.longitude];
                initializeMap();
                startLocationTracking();
                initializeDeviceOrientation();
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });

        // Permission handling
        async function requestPermissions() {
            try {
                const results = await Promise.all([
                    navigator.permissions.query({ name: 'geolocation' }),
                    typeof DeviceOrientationEvent.requestPermission === 'function' 
                        ? DeviceOrientationEvent.requestPermission() 
                        : Promise.resolve('granted')
                ]);
                
                const [geoPermission] = results;
                if (geoPermission.state === 'granted') {
                    return true;
                }
                throw new Error('Location permission denied');
            } catch (error) {
                console.warn('Permission request error:', error);
                throw error;
            }
        }

        // Get current position
        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            });
        }

        // Initialize map
        function initializeMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            userMarker = L.marker(userLocation).addTo(map);
        }

        // Start location tracking
        function startLocationTracking() {
            navigator.geolocation.watchPosition(
                position => {
                    userLocation = [position.coords.latitude, position.coords.longitude];
                    userMarker.setLatLng(userLocation);
                    if (isNavigating) updateNavigation();
                },
                error => console.error('Location error:', error),
                { enableHighAccuracy: true }
            );
        }

        // Initialize device orientation
        function initializeDeviceOrientation() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientationabsolute', handleOrientation, true);
                window.addEventListener('deviceorientation', handleOrientation, true);
            }
        }

        function handleOrientation(event) {
            const currentTime = Date.now();
            if (currentTime - lastUpdateTime < UPDATE_INTERVAL) {
                return;
            }
            lastUpdateTime = currentTime;

            if (event.webkitCompassHeading !== undefined) {
                // iOS devices
                deviceCompassHeading = event.webkitCompassHeading;
            } else if (event.alpha !== null) {
                // Android devices - use alpha directly
                deviceCompassHeading = event.alpha;
                
                // Apply screen orientation correction if needed
                const screenOrientation = (screen.orientation || {}).angle || window.orientation || 0;
                if (screenOrientation !== 0) {
                    deviceCompassHeading = (deviceCompassHeading + screenOrientation) % 360;
                }
            }

            // Debug information
            document.getElementById('debug-info').textContent = 
                `Alpha: ${event.alpha?.toFixed(1)}° | ` +
                `Compass: ${deviceCompassHeading?.toFixed(1)}° | ` +
                `Screen: ${(screen.orientation || {}).angle || window.orientation || 0}°`;

            if (isNavigating) {
                updateNavigation();
            }
        }

        // Start navigation
        async function startNavigation() {
            const destination = document.getElementById('destination').value;
            if (!destination) return;

            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(destination)}`
                );
                const data = await response.json();
                if (data.length === 0) return;

                const destCoords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                createRoute(userLocation, destCoords);
            } catch (error) {
                console.error('Navigation error:', error);
            }
        }

        // Create route
        function createRoute(start, end) {
            if (routingControl) {
                map.removeControl(routingControl);
            }

            routingControl = L.Routing.control({
                waypoints: [
                    L.latLng(start[0], start[1]),
                    L.latLng(end[0], end[1])
                ],
                routeWhileDragging: false,
                show: false
            }).addTo(map);

            routingControl.on('routesfound', handleRouteFound);
        }

        function handleRouteFound(e) {
            routePoints = e.routes[0].coordinates;
            currentRouteIndex = 0;
            isNavigating = true;
            
            const bounds = L.latLngBounds(routePoints);
            map.fitBounds(bounds, { padding: [50, 50] });
            
            updateNavigation();
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation || deviceCompassHeading === null) return;

            const currentPoint = routePoints[currentRouteIndex];
            const nextPoint = routePoints[currentRouteIndex + 1];
            
            if (!currentPoint || !nextPoint) return;

            // Calculate path bearing
            const pathBearing = calculateBearing(
                currentPoint.lat, currentPoint.lng,
                nextPoint.lat, nextPoint.lng
            );

            // Calculate relative bearing based on device heading
            let relativeBearing = (pathBearing - deviceCompassHeading + 360) % 360;
            
            // Normalize to -180 to +180 range
            if (relativeBearing > 180) {
                relativeBearing -= 360;
            }

            // Update AR arrow
            const arrow = document.getElementById('navigation-arrow');
            arrow.style.transform = `translate(-50%, -50%) rotate(${relativeBearing}deg)`;

            // Update debug info
            document.getElementById('debug-info').textContent += 
                ` | Path: ${Math.round(pathBearing)}° | ` +
                `Relative: ${Math.round(relativeBearing)}°`;

            // Check distance to next waypoint
            const distToNext = calculateDistance(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );
            
            if (distToNext < 10 && currentRouteIndex < routePoints.length - 2) {
                currentRouteIndex++;
            }
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const λ1 = lon1 * Math.PI / 180;
            const λ2 = lon2 * Math.PI / 180;

            const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                     Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);

            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
    </script>
</body>
</html>
